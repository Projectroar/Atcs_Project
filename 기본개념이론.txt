7월 15일

좌표계

데카르트 좌표계

왼손좌표계 (Window) 유니티
오른손좌표계(일반수학, OpenGL, 3DMax)

로컬 좌표계 : 특정 물체를 기준으로 한 좌표계 
월드 좌표계 : 월드(맵)의 특정위치를 기준으로 한 좌표계

스크린 좌표계 : 디스플레이의 위치를 표현하기 위한

렌더링 파이프라인
- 모델 생성(로컬좌표 결정)
- 월드 배치(월드 변환,World Transform)
- 카메라 위치와 방향에 따라 변환(카메라 변환, Camera Transform) frustum view 절두체
- 투영 변환(Projection Transform)
- 레스터화(Rasterization)

이산수학
벡터(Vector)
- 힘의 크기(Scalar)와 방향을 나타내는 것
- (x, y, z)
- 단위벡터(Unit Vector) : 크기가 1인 벡터, 방향만 표현하는 벡터
- 정규화(Normalize) : 벢터를 단위벡터로 만드는 작업
- 벡터의 크기 Root(x^2+y^2+z^2)
- 벡터와 벡터의 더하기 = (1,2,3) + (3,6,9) = (4,8,12)
- 벡터와 벡터의 빼기 = (1,2,3) - (3,6,9) = (-2,-4,-6)
- 벡터와 스칼라의 곱하기 = (1,2,3)*5 = (5,10,15)
- 벡터와 스칼라의 나누기 = (1,2,3)/5 =(0.2,0.4,0.6)
- 벡터와 벡터의 곱하기 : 외적(Cross Product)과 내적(Dot Product)구분

***내적 (1,2,3) . (4,5,6) = 1*4 + 2*5 + 3*6 =32
각 항목끼리 곱한 후에 더한 결과
내적의 결과는 스칼라가 나온다

***외적 a x b = (a2b3-a3b2, a3b1-a1b3, a1b2-a2b1)
- 결과 : 두 베터가 만드는 평면에 수직한 벡터 (Normal Vector)를 구한다
- 삼각형의 앞면과 뒷면을 구분할 수 있게 된다

방향 벡터
- 특정 위치에서 특정 위치로 가는 벡터
- 공식 : 도착 위치 - 출발 위치

행렬(MAtrix)
- 숫자를 행과 열로 나열해 놓은 것
- 직사각형의 형태를 띄어랴 한다
- 교환법칙 성립 안됨
- 단위 행렬(숫자 1과 같은 특성을 가진다)
- 역행렬(행렬A와 A의 역행렬을 곱하면 단위행렬이 돤다)
- Transform을 저장한다
(1 2)( 5) 
(3 4)(10)
Translate 행열
TRS = 왼손(유니티)
SRT= 오른손

- 쿼터니언(사원수,Quaternion)
- 숫자 4개로 회전을 표현한다
- 오일러 앵글에서 발생하는 짐벌락현상을
방지할 수 있다 
- 행렬에 비해 더 빠르게 계산이 가능하다
- 유니티는 실제로 쿼터니언사용중
(사람보기 편하게 숫자3개로 보이는중)

충돌영역 - AABB
회전충 - OBB
충돌횟수가 많을경우 구형태가 최적화
구의 충돌 거리 반지름r1+r2= 두 구의 중심점d보다 작은가 큰가

루트사용하지마라? 

연산자(Operator)
- 산술 연산자
- 대입 연산자
- 비교 연산자
- 논리 연산자
- 비트 연산자 : &(and), |(or), <<(left shift), >>(right shift)
                                     (비트에 비해 숫자가 넘치면 없어짐)

정점(Vertex) : 3D모델을 구성하는 점
엣지(Edge) : 정점을 연결한 선
페이스(Face) : 폴리곤. 정점과 엣지를 이용해 만든 면
메시(Mesh) : 페이스를 모아 만든 오브젝트의 형태

보간(Interpolation) : 시작값과 종료값이 있을 때 진행 정도에 따라 
사이값을 계산하는 방식

키프레임 애니메이션
스케일 애니메이션

값형식(Value type)
- struct 상속 받음
- stack 메모리 사용
- 깊은 복사(완전한 사본을 만드는 복사)

참조형식(Reference type)
- class 상속 받음
- heap메모리 사용
- 얕은 복사(주소만 복사)

자료구조(Data Structure)
- 데이터를 어떻게 저장할지를 나타내는 방식

qwe[] a= new int[3];
a[] 32bit
a[] 32bit
a[] 32bit

배열
- 장점 : 랜덤 엑세스 속도가 빠르다
- 단점 : 사이즈가 고정이다. 중간 삽입 삭제가 힘들다

자료구조
리스트(List)
배열처럼 메모리상에 줄줄이 있는 것이 아닌 다음 주소를 가르키는 방식이다
데이터 하나당 node하나 (데이터와 다음노드 주소)
- 장점 : 삽입 삭제가 빠르다
- 단점 : 랜덤 엑세스 속도가 리스트 길이에 비례한다
- 용어
 Node : 데이터 하나
Head : 첫 번쨰 노드
Tail : 마지막 노드
C#의 리스트와 조금 다르다

스택(Stack)
- LIFO(Last In First Out)
- 용어
Top : 스택의 제일 윗부분
Push : 스택에 Top에 데이터를 하나 추가한다
Pop : 스택에 Top에서 데이터를 꺼낸다
스택메모리

큐(Queue)
- FIFO(First In First Out)
- 용어
Front : 큐의 제일 앞부분
Rear : 큐의 제일 뒷부분
Engueue : 큐의 Rear에 데이터 추가
Degueue : 큐의 Front에서 데이터를 꺼냄

위 내용을 선형 자료구조 (Linear Data Structure)라고 한다

트리(Tree)
- 계층 구조를 가진다
- 1 : N구조
    - 부모는 여러개의 자식을 가질 수 있다
    - 자식은 하나의 부모만 가진다
- 용어
Root
Sidling
Leaf or Terminal

이진 탐색 트리(Binary Search Tree)
- 모든 노드는 최대 2개의 자식을 가질 수 있다
- 노드가 유니크한 키값을 가진다
- 키값은 반드시 순서가 있는 값이다 - 중복안됨
- 두 노드를 비교했을 떄 키값이 작으면 왼쪽 크면 
오른쪽에 노드가 있어야 한다

Heap(힙)
(이것도 트리)
- Min Heap과 Max Heap이 있음
- 부모가 자식보다 크면 Max Heap
- 부모가 자식보다 작으면 Min Heap
- 완전 이진트리의 형태를 지닌다

그래프(Graph)
- N:N 구조를 가진다(경로 저장)
- 길찾기 알고리즘에서 많이 사용된다

위에 내용을 비선형 자료구조 라고 한다

알고리즘
- 문제를 해결을 위한 절차

시간 복잡도 : 특정 알고리즘을 이용해서 문제를 해결할 떄 걸리는 시간이 얼마나
걸리는지. 빅오 표기법으로 표현 (O(n), O(logn).....)

공간 복잡도 : 특정 알고리즘을 사용할 때 소비되는 메모리의 양이 얼마나 되는지

해시 알고리즘
- 서로 다른 입력에 대해, 정해진 크기의 유니크한 결과를 리턴하는 알고리즘
- 해시 충돌 : 서로다른 입력값에 대해 같은 결과가 나온 경우

길찾기 알고리즘
- 최단 경로를 찾는 알고리즘
- 다익스트라 알고리즘 
- A* 알고리즘

암호화 알고리즘
- 대칭키 알고리즘 (소프트용 금고 key가 있다)
key값이 무조건 길어야 암호가 잘 된다

- 공개키 알고리즘 : 개인키와 공개키


















localPosition 

right

[RequireComponent(typeof(Animation))]






카메라에 보이는각을 벡터로
90도~270도
내 메모
1. 3D모델 구축 : 자신의 로컬 좌표를 기준으로 점을 이은것
2. 가상공간의 배치 :  월드 좌표로 변환시킨다
암호화시 소인수분해























